<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html">
  <title>plTenjin User's Guide</title>
  <meta name="generator" content="kwaser">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <link rel="stylesheet" href="docstyle.css" type="text/css">
 </head>
 <body>

  <blockquote>
   <div class="mainbody">

    <div align="left"><h1>plTenjin User's Guide</h1></div>
    <div align="left">
      release:     $Release$<br>
      last update: $Date$<br>
    </div>

<p>Table of Contents:
</p>
<ul>
  <li><a href="#intro">Introduction</a>
  <ul>
    <li><a href="#overview">Overview</a>
    </li>
    <li><a href="#features">Features</a>
    </li>
    <li><a href="#comparison">Comparison with other solutions</a>
    </li>
    <li><a href="#benchmark">Benchmark</a>
    </li>
  </ul>
  </li>
  <li><a href="#installation">Installation</a>
  </li>
  <li><a href="#desguide">Designer's Guide</a>
  <ul>
    <li><a href="#des-notation">Notation</a>
    </li>
    <li><a href="#des-convert">Convert into Perl Code</a>
    </li>
    <li><a href="#des-syntaxchk">Syntax Checking</a>
    </li>
    <li><a href="#des-htmlhelpers">HTML Helper Functions</a>
    </li>
    <li><a href="#des-contextdata">Context Data File</a>
    </li>
    <li><a href="#des-cmlinecontext">Command-line Context Data</a>
    </li>
    <li><a href="#des-nested-template">Nested Template</a>
    </li>
    <li><a href="#des-layout">Layout Template</a>
    </li>
    <li><a href="#des-capturing">Capturing</a>
    </li>
    <li><a href="#des-args">Template Arguments</a>
    </li>
    <li><a href="#des-preprocess">Preprocessing</a>
    </li>
    <li><a href="#des-otheropts">Other Options</a>
    </li>
  </ul>
  </li>
  <li><a href="#devguide">Developer's Guide</a>
  <ul>
    <li><a href="#dev-example">An Example</a>
    </li>
    <li><a href="#dev-templateclass">Class Tenjin::Template</a>
    </li>
    <li><a href="#dev-engineclass">Class Tenjin::Engine</a>
    </li>
    <li><a href="#dev-vars-and-funcs">Variables and Functions</a>
    </li>
    <li><a href="#dev-helpers">Add Your Helper Functions</a>
    </li>
    <li><a href="#dev-othertopics">Other Topics</a>
    </li>
  </ul>
  </li>
</ul>
<a name="intro"></a>
<h2 class="section1">Introduction</h2>
<a name="overview"></a>
<h3 class="section2">Overview</h3>
<p>plTenjin is a very fast and lightweight template engine based on embedded Perl.
You can embed Perl statements and expressions into your text file.
plTenjin converts it into Perl script and evaluate it.
</p>
<p>The following is an example of plTenjin.
</p>
<a name="ex.plhtml"></a>
<div class="program_caption">
File 'ex.plhtml':</div>
<pre class="program">Hello <strong>[== $name =]</strong>!
&lt;ul&gt;
<strong>&lt;?pl for my $item (@$items) { ?&gt;</strong>
 &lt;li&gt;<strong>[= $item =]</strong>&lt;/li&gt;
<strong>&lt;?pl } ?&gt;</strong>
&lt;/ul&gt;
</pre>
<p>Here is the notation:
</p>
<dl class="dl3" compact>
<dt class="dt3"><b>
<code>&lt;?pl ... ?&gt;</code> </b></dt>
<dd class="dd3">
	Perl statements.
</dd>
<dt class="dt3"><b>
<code>[== ... =]</code> </b></dt>
<dd class="dd3">
	Perl expression.
</dd>
<dt class="dt3"><b>
<code>[= ... =]</code> </b></dt>
<dd class="dd3">
	Perl expression (HTML escaped)
</dd>
</dl>
<a name="ex_source.result"></a>
<div class="terminal_caption">
Result of covertion into Perl script:</div>
<pre class="terminal">$ pltenjin -s ex.plhtml
my @_buf = (); push(@_buf, q`Hello `,  <strong>$name</strong> , q`!
&lt;ul&gt;
`, ); <strong>for my $item (@$items) {</strong>
push(@_buf, q` &lt;li&gt;`, <strong>escape( $item )</strong>, q`&lt;/li&gt;
`, ); <strong>}</strong>
push(@_buf, q`&lt;/ul&gt;
`, ); join('', @_buf);
</pre>
<a name="ex.result"></a>
<div class="terminal_caption">
Output of execution with context data:</div>
<pre class="terminal">$ pltenjin -w -c "name=&gt;'World', items=&gt;['&lt;AAA&gt;','B&amp;B','\"CCC\"']" ex.plhtml
Hello World!
&lt;ul&gt;
 &lt;li&gt;&amp;lt;AAA&amp;gt;&lt;/li&gt;
 &lt;li&gt;B&amp;amp;B&lt;/li&gt;
 &lt;li&gt;&amp;quot;CCC&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
</pre>
<a name="ex.script"></a>
<div class="program_caption">
Example of Perl script</div>
<pre class="program">use Tenjin;
$Tenjin::USE_STRICT = 1;  # (optional but recommended)
my $engine = new Tenjin::Engine();
my $context = { name=&gt;'World', items=&gt;['&lt;AAA&gt;', 'B&amp;B', '"CCC"'] };
my $output = $engine-&gt;render('ex.plhtml', $context);
print $output;
</pre>
<br>


<a name="features"></a>
<h3 class="section2">Features</h3>
<p>plTenjin has the following features:
</p>
<ul type="disc">
<li>plTenjin runs very fast. It works about three times as fast as Template-Toolkit.
</li>
<li>plTenjin doesn't break HTML design because it uses XML Processing
  Instructions (PI) as embedded notation for Perl statements.
</li>
<li>plTenjin is secure because it supports escaping expression value by default.
</li>
<li>plTenjin is small and lightweight. It is very easy to include plTenjin
  into your application.
</li>
<li>plTenjin supports auto caching of converted Perl code.
</li>
<li>plTenjin supports partial template and layout template.
  These are very useful especially for web application.
</li>
<li>plTenjin supports partial capturing of template.
</li>
<li>plTenjin can load YAML file as context data. Using plTenjin, it is able to
  separate template file and data file.
</li>
</ul>
<br>


<a name="comparison"></a>
<h3 class="section2">Comparison with other solutions</h3>
<p>plTenjin has advantages compared with other solutions (including other language solutions):
</p>
<ul type="disc">
<li><strong>Easy to design</strong> --
  JSP, ePerl, or eRuby breaks HTML design because they use
  '<code>&lt;% ... %&gt;</code>' as embedded notation which is not valid in HTML.
  plTenjin doesn't break HTML desgin because it uses Processing
  Instructions (PI) as embedded notation which is valid in HTML.
</li>
<li><strong>Easy to write</strong> --
  In PHP, it is a little bother to write embedded expression
  because the notation '<code>&lt;?php echo $value; ?&gt;</code>' is a little long,
  and very bother to embed escaped expression because
  '<code>&lt;?php echo htmlspecialchars($value); ?&gt;</code>' is very long.
  In plTenjin, these are very easy to write because embedded expression
  notations ('<code>#{value}</code>' and '<code>${value}</code>') are very short.
</li>
<li><strong>Easy to learn</strong> --
  Some template systems
  are hard to learn because they are large, highly functinal, and
  based on non-Perl syntax.
  plTenjin is very easy to learn if you already know Perl language because
  it is very small and  you can embed any Perl code into HTML template.
</li>
</ul>
<br>


<a name="benchmark"></a>
<h3 class="section2">Benchmark</h3>
<p>Benchmark script is contained in plTenjin archive.
The following is an example of benchmark.
</p>
<div class="terminal_caption">
MacOS X 10.4 Tiger, Intel CoreDuo 1.83GHz, Memory 2GB</div>
<pre class="terminal">$ cd pltenjin-X.X.X/benchmark
$ perl -v | grep built
This is perl, v5.8.8 built for darwin-2level
$ perl -I ../lib bench.pl -n 10000 
*** n = 10000
                          user         sys       total        real
tenjin                  9.8500      0.5700     10.4200     11.0000
tenjin-nocache         16.2500      0.4300     16.6800     17.0000
tenjin-reuse            5.7100      0.0100      5.7200      6.0000
tt                    102.6100      0.9700    103.5800    104.0000
tt-reuse               26.2500      0.0500     26.3000     26.0000
htmltmpl               46.2300      0.4700     46.7000     47.0000
htmltmpl-reuse         30.1700      0.0400     30.2100     31.0000
</pre>
<p>This shows that plTenjin runs about five times faster than Template-Toolkit.
</p>
<br>


<br>


<a name="installation"></a>
<h2 class="section1">Installation</h2>
<ol type="1">
<li>Just copy 'lib/Tenjin.pm' and 'bin/pltenjin' into your proper directory.
</li>
<li>(Optional) Install YAML::Syck package.
</li>
</ol>
<br>


<a name="desguide"></a>
<h2 class="section1">Designer's Guide</h2>
<p>This section shows how to use plTenjin for designer.
</p>
<p>If you want to know how to use plTenjin in your program, see <a href="#devguide">Developer's Guide</a> section.
</p>
<a name="des-notation"></a>
<h3 class="section2">Notation</h3>
<p>The following is the notation of plTenjin.
</p>
<ul type="disc">
<li>'<code>&lt;?pl ... ?&gt;</code>' : Perl statement
</li>
<li>'<code>[== ... =]</code>' : Perl expression
</li>
<li>'<code>[= ... =]</code>' : Perl expression with HTML escape
</li>
</ul>
<a name="example1.plhtml"></a>
<div class="program_caption">
File 'example1.plhtml':</div>
<pre class="program">&lt;table&gt;
  &lt;tbody&gt;
<strong>&lt;?pl my $i = 0; ?&gt;</strong>
<strong>&lt;?pl for my $item (('&lt;foo&gt;', 'bar&amp;bar', '"baz"')) { ?&gt;</strong>
<strong>&lt;?pl     $i++; ?&gt;</strong>
    &lt;tr&gt;
      &lt;td&gt;<strong>[== $item =]</strong>&lt;/td&gt;
      &lt;td&gt;<strong>[= $item =]</strong>&lt;/td&gt;
    &lt;/tr&gt;
<strong>&lt;?pl } ?&gt;</strong>
  &lt;tbody&gt;
&lt;/table&gt;
</pre>
<p>The following is the result of executing 'example1.plhtml'.
</p>
<a name="example1.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin example1.plhtml
&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;<strong>&lt;foo&gt;</strong>&lt;/td&gt;
      &lt;td&gt;<strong>&amp;lt;foo&amp;gt;</strong>&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;<strong>bar&amp;bar</strong>&lt;/td&gt;
      &lt;td&gt;<strong>bar&amp;amp;bar</strong>&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;<strong>"baz"</strong>&lt;/td&gt;
      &lt;td&gt;<strong>&amp;quot;baz&amp;quot;</strong>&lt;/td&gt;
    &lt;/tr&gt;
  &lt;tbody&gt;
&lt;/table&gt;
</pre>
<br>


<a name="des-convert"></a>
<h3 class="section2">Convert into Perl Code</h3>
<p>Command-line option '-s' converts embedded files into Perl code.
</p>
<a name="example1_source.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin <strong>-s</strong> example1.plhtml
my @_buf = (); push(@_buf, q`&lt;table&gt;
  &lt;tbody&gt;
`, ); <strong>my $i = 0;</strong>
<strong>for my $item (('&lt;foo&gt;', 'bar&amp;bar', '"baz"')) {</strong>
    <strong>$i++;</strong>
push(@_buf, q`    &lt;tr&gt;
      &lt;td&gt;`,  <strong>$item</strong> , q`&lt;/td&gt;
      &lt;td&gt;`, <strong>escape( $item )</strong>, q`&lt;/td&gt;
    &lt;/tr&gt;
`, ); <strong>}</strong>
push(@_buf, q`  &lt;tbody&gt;
&lt;/table&gt;
`, ); join('', @_buf);
</pre>
<ul type="disc">
<li>Variable <code>@_buf</code> is a list.
</li>
<li>Function <code>escape()</code> (= <code>Tenjin::Context::escape()</code>) escapes <code>'&amp; &lt; &gt; "'</code> into <code>'&amp;amp; &amp;lt; &amp;gt; &amp;quot;'</code>.
  Command-line option <code>--escapefunc=<em>func</em></code> makes pltenjin to use <code><em>func</em>()</code> instead of <code>escape()</code>.
</li>
<li>End-of-line character ("\n" or "\r\n") is automatically detected by plTenjin.
</li>
</ul>
<p>'<code>@_buf = ();</code>' is called as preamble and '<code>join('', @_buf);</code>' is called as postamble.
Command-line option '<code>-b</code>' removes preamble and postamble.
</p>
<a name="example2.plhtml"></a>
<div class="program_caption">
File 'example2.plhtml'</div>
<pre class="program">&lt;?pl for my $i ((1, 2, 3)) { ?&gt;
&lt;p&gt;[== $i =]&lt;/p&gt;
&lt;?pl } ?&gt;
</pre>
<a name="example2_sb.result2"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin -s example2.plhtml
<strong>my @_buf = ();</strong> for my $i ((1, 2, 3)) {
push(@_buf, q`&lt;p&gt;`,  $i , q`&lt;/p&gt;
`, ); }
<strong>join('', @_buf);</strong>
$ pltenjin -s<strong>b</strong> example2.plhtml
for my $i ((1, 2, 3)) {
push(@_buf, q`&lt;p&gt;`,  $i , q`&lt;/p&gt;
`, ); }
</pre>
<p>Command-line option '-S' also show converted Perl code but it doesn't print text part.
This is useful to check Perl code for debugging.
</p>
<a name="example1_S.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin <strong>-S</strong> example1.plhtml
my @_buf = (); 

my $i = 0;
for my $item (('&lt;foo&gt;', 'bar&amp;bar', '"baz"')) {
    $i++;

           $item ; 
          escape( $item ); 

}


join('', @_buf);
</pre>
<p>In addition, the following command-line options are available.
</p>
<dl class="dl3" compact>
<dt class="dt3"><b>
-N </b></dt>
<dd class="dd3">
	     Add line number.
</dd>
<dt class="dt3"><b>
-X </b></dt>
<dd class="dd3">
	     Delete expressions.
</dd>
<dt class="dt3"><b>
-C </b></dt>
<dd class="dd3">
	     Remove empty lines (compact-mode).
</dd>
<dt class="dt3"><b>
-U </b></dt>
<dd class="dd3">
	     Compress empty lines to a line (uniq-mode).
</dd>
</dl>
<a name="example1_SXNC.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin <strong>-SUNX</strong> example1.plhtml
    1:  my @_buf = (); 

    3:  my $i = 0;
    4:  for my $item (('&lt;foo&gt;', 'bar&amp;bar', '"baz"')) {
    5:      $i++;

   10:  }

   13:  join('', @_buf);
</pre>
<br>


<a name="des-syntaxchk"></a>
<h3 class="section2">Syntax Checking</h3>
<p>Command-line option '<code>-z</code>' checks syntax error in embedded Perl code
and command-line option '<code>-w</code>' enables 'use strict;'.
It is recommended to use '-w' when you specify '-z'.
</p>
<a name="example3.plhtml"></a>
<div class="program_caption">
File example3.plhtml:</div>
<pre class="program">&lt;ul&gt;
&lt;?pl for my $item (@$items) { ?&gt;
  &lt;li&gt;[= $item =]&lt;/li&gt;
&lt;?pl <strong>#}</strong> ?&gt;
&lt;/ul&gt;
</pre>
<a name="example3_syntaxcheck.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin <strong>-z</strong> example3.plhtml
*** example3.plhtml - NG
Missing right curly or square bracket at example3.plhtml line 6, at end of line
syntax error at example3.plhtml line 6, at EOF
example3.plhtml had compilation errors.
</pre>
<p>Command-line option '-wz' is more convenient than '<code>pltenjin -s file | perl -wc</code>'
because the former can take several filenames.
</p>
<p>Command-line option '-q' (quiet-mode) prints nothing if it has no errors.
</p>
<br>


<a name="des-htmlhelpers"></a>
<h3 class="section2">HTML Helper Functions</h3>
<p>plTenjin provides small but useful HTML helper functions.
See <a href="#dev-htmlhelpers">this section</a> for details.
</p>
<a name="htmlhelpers.plhtml"></a>
<div class="program_caption">
example of HTML helper functions:</div>
<pre class="program"></pre>
<a name="htmlhelpers.output"></a>
<div class="program_caption">
output example:</div>
<pre class="program">&lt;table&gt;
  &lt;tr class="<strong>odd</strong>" &gt;
    &lt;td&gt;&lt;input type="checkbox" name="items" value="1"  /&gt;&lt;/td&gt;
    &lt;td&gt;Foo&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr class="<strong>even</strong>"  <strong>style="color:gray"</strong>&gt;
    &lt;td&gt;&lt;input type="checkbox" name="items" value="2"  <strong>checked="checked"</strong> /&gt;&lt;/td&gt;
    &lt;td&gt;Bar&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</pre>
<br>


<a name="des-contextdata"></a>
<h3 class="section2">Context Data File</h3>
<p>plTenjin allows you to specify context data by YAML file or Perl script.
</p>
<a name="example4.plhtml"></a>
<div class="program_caption">
File 'example4.plhtml':</div>
<pre class="program">&lt;p&gt;
  [= $text =]
  [== $num =]
  [== $flag =]
&lt;/p&gt;

&lt;?pl for my $item (@$items) { ?&gt;
&lt;p&gt;[= $item =]&lt;/p&gt;
&lt;?pl } ?&gt;

&lt;?pl while (my ($key, $value) = each %$hash) { ?&gt;
&lt;p&gt;[= $key =] = [= $value =]&lt;/p&gt;
&lt;?pl } ?&gt;
</pre>
<a name="datafile.yaml"></a>
<div class="program_caption">
File 'datafile.yaml':</div>
<pre class="program">text:   foo
num:    3.14
flag:   yes
items:
  - foo
  - bar
  - baz
hash:
  x: 1
  y: 2
</pre>
<a name="example4_yaml.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin <strong>-f datafile.yaml</strong> example4.plhtml
&lt;p&gt;
  foo
  3.14
  yes
&lt;/p&gt;

&lt;p&gt;foo&lt;/p&gt;
&lt;p&gt;bar&lt;/p&gt;
&lt;p&gt;baz&lt;/p&gt;

&lt;p&gt;y = 2&lt;/p&gt;
&lt;p&gt;x = 1&lt;/p&gt;
</pre>
<a name="datafile.pl"></a>
<div class="program_caption">
File 'datafile.pl':</div>
<pre class="program">{
  text  =&gt; "foo",
  num   =&gt; 3.14,
  flag  =&gt; 1,
  items =&gt; ['foo', 'bar', 'baz'],
  hash  =&gt; { x=&gt;1, y=&gt;2, },
}
</pre>
<a name="example4_datafile_pl.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin <strong>-f datafile.pl</strong> example4.plhtml
&lt;p&gt;
  foo
  3.14
  1
&lt;/p&gt;

&lt;p&gt;foo&lt;/p&gt;
&lt;p&gt;bar&lt;/p&gt;
&lt;p&gt;baz&lt;/p&gt;

&lt;p&gt;y = 2&lt;/p&gt;
&lt;p&gt;x = 1&lt;/p&gt;
</pre>
<p>You must install YAML::Syck package if you want to use YAML-format context data file.
</p>
<br>


<a name="des-cmlinecontext"></a>
<h3 class="section2">Command-line Context Data</h3>
<p>Command-line option '<code>-c</code>' specifies context data in YAML format or Perl code.
</p>
<a name="example5.plhtml"></a>
<div class="program_caption">
File 'example5.plhtml':</div>
<pre class="program">text:  [=$text=]
items:
&lt;?pl for my $item (@$items) { ?&gt;
  - [=$item=]
&lt;?pl } ?&gt;
hash:
&lt;?pl while (my ($key, $val) = each %$hash) { ?&gt;
  [=$key=]: [=$val=]
&lt;?pl } ?&gt;
</pre>
<a name="example5_datastr_pl.result"></a>
<div class="terminal_caption">
Result of context data in perl code:</div>
<pre class="terminal">$ pltenjin <strong>-c 'text=&gt;"foo", items=&gt;["a","b","c"], hash=&gt;{x=&gt;1,y=&gt;2}'</strong> example5.plhtml
text:  foo
items:
  - a
  - b
  - c
hash:
  y: 2
  x: 1
</pre>
<a name="example5_datastr_yaml.result"></a>
<div class="terminal_caption">
Result of context data in yaml format:</div>
<pre class="terminal">$ pltenjin <strong>-c '{text: foo, items: [a, b, c], hash: {x: 1, y: 2} }'</strong> example5.plhtml
text:  foo
items:
  - a
  - b
  - c
hash:
  y: 2
  x: 1
</pre>
<p>You must install YAML::Syck package at first if you want to specify context data in YAML format.
</p>
<br>


<a name="des-nested-template"></a>
<h3 class="section2">Nested Template</h3>
<p>Template can include other templates.
Included templates can also include other templates.
</p>
<p>The following function is available to include other templates.
</p>
<dl class="dl3">
<dt class="dt3"><b>
include(str template_name) </b></dt>
<dd class="dd3">
    Include other template.
</dd>
</dl>
<a name="example6.plhtml"></a>
<div class="program_caption">
File 'example6.plhtml':</div>
<pre class="program">&lt;html&gt;
  &lt;body&gt;

    &lt;div id="sidemenu"&gt;
<strong>&lt;?pl include('sidemenu.plhtml'); ?&gt;</strong>
    &lt;/div&gt;

    &lt;div id="main-content"&gt;
&lt;?pl for my $item (@$items) { ?&gt;
      &lt;p&gt;[=$item=]&lt;/p&gt;
&lt;?pl } ?&gt;
    &lt;/div&gt;

    &lt;div id="footer"&gt;
<strong>&lt;?pl include('footer.plhtml'); ?&gt;</strong>
    &lt;/div&gt;

  &lt;/body&gt;
&lt;/table&gt;
</pre>
<a name="sidemenu.plhtml"></a>
<div class="program_caption">
File 'sidemenu.plhtml':</div>
<pre class="program">&lt;ul&gt;
&lt;?pl for my $item (@$menu) { ?&gt;
  &lt;li&gt;&lt;a href="[=$item-&gt;{'url'}=]"&gt;[=$item-&gt;{'name'}=]&lt;/a&gt;&lt;/li&gt;
&lt;?pl } ?&gt;
&lt;/ul&gt;
</pre>
<a name="footer.plhtml"></a>
<div class="program_caption">
File 'footer.plhtml':</div>
<pre class="program">&lt;hr /&gt;
&lt;address&gt;
  &lt;a href="mailto:[=$webmaster_email=]"&gt;[=$webmaster_email=]&lt;/a&gt;
&lt;/address&gt;
</pre>
<a name="contextdata.pl"></a>
<div class="program_caption">
File 'contextdata.pl':</div>
<pre class="program">{
    items =&gt; [ '&lt;FOO&gt;', '&amp;BAR', '"BAZ"' ],
    webmaster_email =&gt; 'webmaster@example.com',
    menu  =&gt; [
        { name =&gt; 'Top',      url =&gt; '/' },
        { name =&gt; 'Products', url =&gt; '/prod' },
        { name =&gt; 'Support',  url =&gt; '/support' },
    ],
}
</pre>
<a name="example6_nested.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin -f contextdata.pl example6.plhtml
&lt;html&gt;
  &lt;body&gt;

    &lt;div id="sidemenu"&gt;
<strong>&lt;ul&gt;</strong>
  <strong>&lt;li&gt;&lt;a href="/"&gt;Top&lt;/a&gt;&lt;/li&gt;</strong>
  <strong>&lt;li&gt;&lt;a href="/prod"&gt;Products&lt;/a&gt;&lt;/li&gt;</strong>
  <strong>&lt;li&gt;&lt;a href="/support"&gt;Support&lt;/a&gt;&lt;/li&gt;</strong>
<strong>&lt;/ul&gt;</strong>
    &lt;/div&gt;

    &lt;div id="main-content"&gt;
      &lt;p&gt;&amp;lt;FOO&amp;gt;&lt;/p&gt;
      &lt;p&gt;&amp;amp;BAR&lt;/p&gt;
      &lt;p&gt;&amp;quot;BAZ&amp;quot;&lt;/p&gt;
    &lt;/div&gt;

    &lt;div id="footer"&gt;
<strong>&lt;hr /&gt;</strong>
<strong>&lt;address&gt;</strong>
<strong>  &lt;a href="mailto:webmaster@example.com"&gt;webmaster@example.com&lt;/a&gt;</strong>
<strong>&lt;/address&gt;</strong>
    &lt;/div&gt;

  &lt;/body&gt;
&lt;/table&gt;
</pre>
<p>'<code>include()</code>' can take template filename
(ex. 'user_main.plhtml') or template short name (ex. ':main').
Template short name represents a template in short notation. It starts with colon (':').
</p>
<p>To make template short name available, command-line option '<code>--prefix</code>' and
'<code>--postfix</code>' are required.
For example, '<code>include("user_main.plhtml")</code>' can be described as '<code>include(":main")</code>'
when '<code>--prefix="user_"</code>' and '<code>--postfix=".plhtml"</code>' are specified in command-line.
</p>
<br>


<a name="des-layout"></a>
<h3 class="section2">Layout Template</h3>
<p>Command-line option '<code>--layout=templatename</code>' specifies layout template name.
</p>
<p>For example, 'exmample6.plhtml' template in the previous section can be divided
into layout file 'layout6.plhtml' and content file 'content6.plhtml'.
Variable '<code>$_content</code>' in layout template represents the result of content file.
</p>
<a name="layout6.plhtml"></a>
<div class="program_caption">
File 'layout6.plhtml':</div>
<pre class="program">&lt;html&gt;
  &lt;body&gt;

    &lt;div id="sidemenu"&gt;
&lt;?pl include('sidemenu.plhtml'); ?&gt;
    &lt;/div&gt;

    &lt;div id="main-content"&gt;
<strong>[== $_content ==]</strong>
    &lt;/div&gt;

    &lt;div id="footer"&gt;
&lt;?pl include('footer.plhtml'); ?&gt;
    &lt;/div&gt;

  &lt;/body&gt;
&lt;/table&gt;
</pre>
<a name="content6.plhtml"></a>
<div class="program_caption">
File 'content6.plhtml':</div>
<pre class="program">&lt;?pl for my $item (@$items) { ?&gt;
  &lt;p&gt;[=$item=]&lt;/p&gt;
&lt;?pl } ?&gt;
</pre>
<a name="example6_layout.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin -f contextdata.pl <strong>--layout=layout6.plhtml</strong> content6.plhtml
&lt;html&gt;
  &lt;body&gt;

    &lt;div id="sidemenu"&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="/"&gt;Top&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/prod"&gt;Products&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href="/support"&gt;Support&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;/div&gt;

    &lt;div id="main-content"&gt;
<strong>  &lt;p&gt;&amp;lt;FOO&amp;gt;&lt;/p&gt;</strong>
<strong>  &lt;p&gt;&amp;amp;BAR&lt;/p&gt;</strong>
<strong>  &lt;p&gt;&amp;quot;BAZ&amp;quot;&lt;/p&gt;</strong>
    &lt;/div&gt;

    &lt;div id="footer"&gt;
&lt;hr /&gt;
&lt;address&gt;
  &lt;a href="mailto:webmaster@example.com"&gt;webmaster@example.com&lt;/a&gt;
&lt;/address&gt;
    &lt;/div&gt;

  &lt;/body&gt;
&lt;/table&gt;
</pre>
<p>Target template and layout template don't share local variables.
It means that local variables set in a template are not available in layout template.
</p>
<p>If you want variables set in a temlate to be available in layout template,
you should use '$_context' hash reference.
</p>
<a name="layout7.plhtml"></a>
<div class="program_caption">
File 'layout7.plhtml':</div>
<pre class="program">...
&lt;h1&gt;<strong>[=$title=]</strong>&lt;/h1&gt;

&lt;div id="main-content"&gt;
[==$_content==]
&lt;div&gt;

&lt;a href="<strong>[=$url=]</strong>"&gt;Next page&lt;/a&gt;
...
</pre>
<a name="content7.plhtml"></a>
<div class="program_caption">
File 'content7.plhtml':</div>
<pre class="program"><strong>&lt;?pl $_context-&gt;{'title'} = 'Document Title'; ?&gt;</strong>
<strong>&lt;?pl $_context-&gt;{'url'}   = '/next/page'; ?&gt;</strong>
&lt;table&gt;
  ...content...
&lt;/table&gt;
</pre>
<a name="example7_layout2.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin --layout=layout7.plhtml content7.plhtml
...
&lt;h1&gt;<strong>Document Title</strong>&lt;/h1&gt;

&lt;div id="main-content"&gt;
&lt;table&gt;
  ...content...
&lt;/table&gt;
&lt;div&gt;

&lt;a href="<strong>/next/page</strong>"&gt;Next page&lt;/a&gt;
...
</pre>
<p>Using '$_context-&gt;{_layout}', it is able to specify layout template name in each template file.
If you assigned 0 to '$_context-&gt;{_layout}', no layout template is used.
</p>
<a name="content8.plhtml"></a>
<div class="program_caption">
File 'content8.plhtml':</div>
<pre class="program"><strong>&lt;?pl $_context-&gt;{'_layout'} = ':layout8_xhtml'; ?&gt;</strong>
&lt;h1&gt;Hello World!&lt;/h1&gt;
</pre>
<a name="layout8_html.plhtml"></a>
<div class="program_caption">
File 'layout8_html.plhtml':</div>
<pre class="program">&lt;html&gt;
  &lt;body&gt;
[== $_content ==]
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<a name="layout8_xhtml.plhtml"></a>
<div class="program_caption">
File 'layout8_xhtml.plhtml':</div>
<pre class="program">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
  &lt;body&gt;
[== $_content ==]
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<a name="example8_layout3.result"></a>
<div class="terminal_caption">
Result: ':layout8_html' is specified in command-line option but ':layout8_xhtml' is used</div>
<pre class="terminal">$ pltenjin --postfix='.plhtml' <strong>--layout=':layout8_html'</strong> content8.plhtml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
  &lt;body&gt;
&lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<br>


<a name="des-capturing"></a>
<h3 class="section2">Capturing</h3>
<p>It is able to capture any part of template.
</p>
<a name="example9.plhtml"></a>
<div class="program_caption">
File 'example9.plhtml':</div>
<pre class="program">&lt;?pl $_context-&gt;{'title'} = 'Capture Test'; ?&gt;
&lt;html&gt;
  &lt;body&gt;

<strong>&lt;?pl start_capture('content_part'); ?&gt;</strong>
    &lt;ul&gt;
&lt;?pl for my $i ((0, 1, 2)) { ?&gt;
      &lt;li&gt;i = [==$i=]&lt;/li&gt;
&lt;?pl } ?&gt;
    &lt;/ul&gt;
<strong>&lt;?pl stop_capture(); ?&gt;</strong>

<strong>&lt;?pl start_capture('footer_part'); ?&gt;</strong>
    &lt;div class="footer"&gt;copyright&amp;copy; 2007 kuwata-lab.com&lt;/div&gt;
<strong>&lt;?pl stop_capture() ?&gt;</strong>

  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Captured strings are accessable as local variables.
For example, you can get captured string as a variable '<code>content_part</code>' in the above example.
</p>
<p>A template can contain several capturing.
It is not able to nest capturing.
</p>
<p>In layout file, it is able to use strings captured in templates.
</p>
<a name="layout9.plhtml"></a>
<div class="program_caption">
File 'layout9.plhtml':</div>
<pre class="program">&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;[=$title=]&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;!-- HEADER --&gt;
<strong>&lt;?pl start_placeholder('header_part'); ?&gt;</strong>
    &lt;h1&gt;[=$title=]&lt;/h1&gt;
<strong>&lt;?pl stop_placeholder(); ?&gt;</strong>
    &lt;!-- /HEADER --&gt;

    &lt;!-- CONTENT --&gt;
<strong>[== $content_part ==]</strong>
    &lt;!-- /CONTENT --&gt;

    &lt;!-- FOOTER --&gt;
<strong>&lt;?pl start_placeholder('footer_part'); ?&gt;</strong>
    &lt;hr /&gt;
    &lt;address&gt;webmaster@localhost&lt;/address&gt;
<strong>&lt;?pl stop_placeholder(); ?&gt;</strong>
    &lt;!-- /FOOTER --&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>'<code>start_placeholder("name") ... stop_placeholder()</code>' is quivarent to the following.
</p>
<pre class="program"><strong>&lt;?pl if ($_context-&gt;{"name"}) { ?&gt;</strong>
[== $_context-&gt;{"name"} ==]
<strong>&lt;?pl } else { ?&gt;</strong>
    ...
<strong>&lt;?pl } ?&gt;</strong>
</pre>
<p>The following result shows that content part and footer part are overrided by capturing in content template but header part is not.
</p>
<a name="example9_capture.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin --layout=layout9.plhtml example9.plhtml
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;Capture Test&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;!-- HEADER --&gt;
    &lt;h1&gt;Capture Test&lt;/h1&gt;
    &lt;!-- /HEADER --&gt;

    &lt;!-- CONTENT --&gt;
    <strong>&lt;ul&gt;</strong>
      <strong>&lt;li&gt;i = 0&lt;/li&gt;</strong>
      <strong>&lt;li&gt;i = 1&lt;/li&gt;</strong>
      <strong>&lt;li&gt;i = 2&lt;/li&gt;</strong>
    <strong>&lt;/ul&gt;</strong>
    &lt;!-- /CONTENT --&gt;

    &lt;!-- FOOTER --&gt;
    <strong>&lt;div class="footer"&gt;copyright&amp;copy; 2007 kuwata-lab.com&lt;/div&gt;</strong>
    &lt;!-- /FOOTER --&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>
<br>


<a name="des-args"></a>
<h3 class="section2">Template Arguments</h3>
<p>It is able to specify template arguments in template files.
Template arguments are variables which are passed by main program via context object.
In the following example, '<code>title</code>' and '<code>name</code>' are template arguments.
</p>
<a name="example10.plhtml"></a>
<div class="program_caption">
File 'example10.plhtml':</div>
<pre class="program">&lt;?xml version="1.0"?&gt;
<strong>&lt;?pl #@ARGS title, name ?&gt;</strong>
&lt;h1&gt;[=$title=]&lt;/h1&gt;
&lt;p&gt;Hello [=$name=]!&lt;/p&gt;
</pre>
<p>Template arguments line is converted into assignment statements of local variables.
</p>
<a name="example10_template_args.result"></a>
<pre class="terminal">$ pltenjin -s example10.plhtml
my @_buf = (); push(@_buf, q`&lt;?xml version="1.0"?&gt;
`, ); my $title = $_context-&gt;{title}; my $name = $_context-&gt;{name}; 
push(@_buf, q`&lt;h1&gt;`, escape($title), q`&lt;/h1&gt;
&lt;p&gt;Hello `, escape($name), q`!&lt;/p&gt;
`, ); join('', @_buf);
</pre>
<p>If template arguments are specified, other variables passed by context object are not set.
</p>
<a name="example11.plhtml"></a>
<div class="program_caption">
File 'example11.plhtml':</div>
<pre class="program"><strong>&lt;?pl #@ARGS x ?&gt;</strong>
&lt;p&gt;
x = [=$x=]
y = [=$y=]   # error
&lt;/p&gt;
</pre>
<a name="example11_template_args.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ pltenjin <strong>-wc 'x=&gt;10,y=&gt;20'</strong> example11.plhtml
*** Error: example11.plhtml
Global symbol "$y" requires explicit package name at (eval 4) line 4.
</pre>
<p>Special variable '<code>$_context</code>' which represents context object is always available whether template arguments are specified or not.
</p>
<br>


<a name="des-preprocess"></a>
<h3 class="section2">Preprocessing</h3>
<p>plTenjin supports preprocessing of template.
Preprocessing executes some logics when templates are loaded and that logics are not executed when rendering.
Preprocessing makes your application much faster.
</p>
<p>Notation of preprocessing is the following.
</p>
<ul type="disc">
<li><code>&lt;?PL ... ?&gt;</code> represents preprocessing statement.
</li>
<li><code>[*=...=*]</code> represents preprocessing expression (with HTML escape).
</li>
<li><code>[*==...=*]</code> represents preprocessing expression (without HTML escape).
</li>
</ul>
<p>For example, assume the following template.
</p>
<a name="example12.plhtml"></a>
<div class="program_caption">
File 'example12.plhtml':</div>
<pre class="program"><strong>&lt;?PL %states = ( "CA" =&gt; "California", ?&gt;</strong>
<strong>&lt;?PL             "NY" =&gt; "New York", ?&gt;</strong>
<strong>&lt;?PL             "FL" =&gt; "Florida",  ?&gt;</strong>
<strong>&lt;?PL             "TX" =&gt; "Texas",  ?&gt;</strong>
<strong>&lt;?PL             "HI" =&gt; "Hawaii", ); ?&gt;</strong>
&lt;?pl %chk = ( $params-&gt;{state} =&gt; ' selected="selected"' ); ?&gt;
&lt;select name="state"&gt;
  &lt;option value=""&gt;-&lt;/option&gt;
<strong>&lt;?PL for my $code (sort(keys(%states))) { ?&gt;</strong>
  &lt;option value="<strong>[*==$code=*]</strong>"[=$chk-&gt;{<strong>[*==$code=*]</strong>}=]&gt;<strong>[*==$states{$code}=*]</strong>&lt;/option&gt;
<strong>&lt;?PL } ?&gt;</strong>
&lt;/select&gt;
</pre>
<p>If preprocessing is activated, the above will be converted into the following when template is loaded.
(Command-line option <code>-P</code> shows the result of preprocessing.)
</p>
<a name="example12_preprocessed.result"></a>
<div class="terminal_caption">
Result of preprocessing:</div>
<pre class="terminal">$ pltenjin <strong>-P</strong> example12.plhtml
&lt;?pl %chk = ( $params-&gt;{state} =&gt; ' selected="selected"' ); ?&gt;
&lt;select name="state"&gt;
  &lt;option value=""&gt;-&lt;/option&gt;
  &lt;option value="CA"[=$chk-&gt;{CA}=]&gt;California&lt;/option&gt;
  &lt;option value="FL"[=$chk-&gt;{FL}=]&gt;Florida&lt;/option&gt;
  &lt;option value="HI"[=$chk-&gt;{HI}=]&gt;Hawaii&lt;/option&gt;
  &lt;option value="NY"[=$chk-&gt;{NY}=]&gt;New York&lt;/option&gt;
  &lt;option value="TX"[=$chk-&gt;{TX}=]&gt;Texas&lt;/option&gt;
&lt;/select&gt;
</pre>
<p>This means that for-loop is executed only once when template is loaded and is not executed when rendering.
In the result, rendering speed becomes to be much faster.
</p>
<p>And the Perl code is here. This shows that there is no for-loop.
</p>
<a name="example12_preprocessed_source.result"></a>
<div class="terminal_caption">
Translated script code:</div>
<pre class="terminal">$ pltenjin <strong>--preprocess</strong> -sb example12.plhtml
%chk = ( $params-&gt;{state} =&gt; ' selected="selected"' );
push(@_buf, q`&lt;select name="state"&gt;
  &lt;option value=""&gt;-&lt;/option&gt;
  &lt;option value="CA"`, escape($chk-&gt;{CA}), q`&gt;California&lt;/option&gt;
  &lt;option value="FL"`, escape($chk-&gt;{FL}), q`&gt;Florida&lt;/option&gt;
  &lt;option value="HI"`, escape($chk-&gt;{HI}), q`&gt;Hawaii&lt;/option&gt;
  &lt;option value="NY"`, escape($chk-&gt;{NY}), q`&gt;New York&lt;/option&gt;
  &lt;option value="TX"`, escape($chk-&gt;{TX}), q`&gt;Texas&lt;/option&gt;
&lt;/select&gt;
`, ); 
</pre>
<p>If you have errors on preprocessing, you should check source script by <code>-Ps</code> option<sup>(<a href="#fnref:1" name="fnlink:1">*1</a>)</sup>.
</p>
<p>The following is an another example.
Assume that <code>link_to()</code> is a helper method which takes label and url and generate
<code>&lt;a&gt;&lt;/a&gt;</code> tag.
In this case, label and url can be parameterized by <code>_p("...")</code> and <code>_P("...")</code>.
The former is converted into <code>[== ... =]</code> and the latter converted into <code>[= ... =]</code>
by preprocessor.
</p>
<a name="example13.plhtml"></a>
<div class="program_caption">
File 'example13.plhtml':</div>
<pre class="program">&lt;?PL ## ex. link_to('Show', '/show/1')  =&gt; &lt;a href="/show/1"&gt;Show&lt;/a&gt; ?&gt;
&lt;?PL sub link_to { ?&gt;
&lt;?PL   my($label, $url) = @_; ?&gt;
&lt;?PL   return sprintf('&lt;a href="%s"&gt;%s&lt;/a&gt;', Tenjin::Helper::Html::encode_url($url), $label); ?&gt;
&lt;?PL } ?&gt;
[*==link_to('"Show '._P('$item-&gt;{"name"}').'"', '/items/show/'._p('$item-&gt;{"id"}'))=*]
</pre>
<a name="example13_preprocessed.result"></a>
<div class="terminal_caption">
Preprocessed template:</div>
<pre class="terminal">$ pltenjin <strong>-P</strong> example13.plhtml
&lt;a href="/items/show/<strong>[==$item-&gt;{"id"}=]</strong>"&gt;"Show <strong>[=$item-&gt;{"name"}=]</strong>"&lt;/a&gt;
</pre>
<a name="example13_preprocessed_source.result"></a>
<div class="terminal_caption">
Translated script code:</div>
<pre class="terminal">$ pltenjin <strong>--preprocess</strong> -sb example13.plhtml
push(@_buf, q`&lt;a href="/items/show/`, $item-&gt;{"id"}, q`"&gt;"Show `, escape($item-&gt;{"name"}), q`"&lt;/a&gt;
`, ); 
</pre>
<p>There are many web-application framework and they provides helper functions.
These helper functions are divided into two groups.
</p>
<ul type="disc">
<li><code>link_to()</code> or <code>_()</code> (function for M17N) return the same result
   when the same arguments are passed.
   These functions can be expanded by preprocessor.
</li>
<li>Some functions return the different result even if the same arguments are passed.
   These functions can't be expaned by preprocessor.
</li>
</ul>
<p>Preprocessor has the power to make your application much faster,
but it may make the debugging difficult.
You should use it carefully.
</p>
<div class="footnote">
 <dl compact>
  <dt>(<a name="fnref:1" href="#fnlink:1">*1</a>)</dt>
  <dd>Command-line option '-Ps' is available but '-PS' is not availabe. This is a current restriction of pltenjin. </dd>
 </dl>
</div>
<br>


<a name="des-otheropts"></a>
<h3 class="section2">Other Options</h3>
<ul type="disc">
<li>Command-line option '-w' uses strict package. This is useful for development.
</li>
<li>Command-line option '<code>--escapefunc=func1</code>' changes <code>escape()</code> function name to <code>func1</code>.
   For example, '<code>--escapefunc=HTML::Entities::encode_entities</code>' changes escape function from <code>esca;e()</code> to <code>HTML::Entities::encode_entities()</code>.
</li>
<li>Command-line option '<code>--path=dir1,dir2,...</code>' sepcifies template directory path.
</li>
</ul>
<br>


<br>


<a name="devguide"></a>
<h2 class="section1">Developer's Guide</h2>
<p>This section shows how to use plTenjin in your Perl script.
</p>
<p>If you want to know the notation or features of plTenjin, see <a href="#desguide">Designer's Guide</a> section.
</p>
<a name="dev-example"></a>
<h3 class="section2">An Example</h3>
<p>The following is an example to use plTenjin in Perl.
</p>
<div class="program_caption">
Example:</div>
<pre class="program">use Tenjin;
$Tenjin::USE_STRICT = 1;    # (optional but recommended)
my $engine = new Tenjin::Engine();
my $context = { title=&gt;'plTenjin Example', items=&gt;['AAA', 'BBB', 'CCC'] };
my $filename = 'file.plhtml';
my $output = $engine-&gt;render($filename, $context);
print $output;
</pre>
<p>If you want to define helper functions for template, see <a href="#dev-helpers">Add Your Helper Functions</a> section.
</p>
<br>


<a name="dev-templateclass"></a>
<h3 class="section2">Class Tenjin::Template</h3>
<p>Tenjin::Template class represents a template file.
An object of Tenjin::Template corresponds to a template file.
Main responsibilities of this class are:
</p>
<ul type="circle">
<li>Convert template file into perl script
</li>
<li>Render converted perl script with context data
</li>
</ul>
<p>This class has the following methods and attributes.
</p>
<dl class="dl3">
<dt class="dt3"><b>
Tenjin::Template::new(filename=nil, :escapefunc=&gt;'escape') </b></dt>
<dd class="dd3">
    Create template object. If filename is given, read and convert it to Perl code.
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
Tenjin::Template::convert(input, filename=None) </b></dt>
<dd class="dd3">
    Convert input text into Perl code and return it.
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
Tenjin::Template::convert_file(filename) </b></dt>
<dd class="dd3">
    Convert file into Perl code and return it.
    This is equivarent to <code>Tenjin::Template#convert(Tenjin::Util::read_file(filename), filename)</code>
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
Tenjin::Template::render(context=undef) </b></dt>
<dd class="dd3">
    Compile Perl code, evaluate it with context data, and return the result of evaluation.
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
Tenjin::Template-&gt;{'script'} </b></dt>
<dd class="dd3">
    Converted Perl code
</dd>
</dl>
<p>The followings are examples to use Tenjin::Template in Perl script.
</p>
<a name="example14.plhtml"></a>
<div class="program_caption">
File 'example14.plhtml':</div>
<pre class="program">&lt;h1&gt;[=$title=]&lt;/h1&gt;
&lt;ul&gt;
&lt;?pl for my $item (@$items) { ?&gt;
 &lt;li&gt;[=$item=]&lt;/li&gt;
&lt;?pl } ?&gt;
&lt;/ul&gt;
</pre>
<a name="example14.pl"></a>
<div class="program_caption">
File 'example14.pl':</div>
<pre class="program">## template file
my $filename = 'example14.plhtml';

## convert into perl code
use Tenjin;
my $template = <strong>new Tenjin::Template($filename)</strong>;
## or
# my $template = new Tenjin::Template();
# my $script = <strong>$template-&gt;convert_file{$filename}</strong>;
## or
# my $template = new Tenjin::Template();
# my $input = Tenjin::Util::read_file($filename);
# my $script = <strong>$template-&gt;convert($input, $filename)</strong>;  # filename is optional

## show converted perl code
print "---- perl code ----\n";
print <strong>$template-&gt;{'script'}</strong>;

## evaluate perl code
my $context = { title=&gt;'plTenjin Example', items=&gt;['&lt;AAA&gt;','B&amp;B','"CCC"'], };
my $output = <strong>$template-&gt;render($context)</strong>;
print "---- output ----\n";
print $output;
## or
#my $context = { title=&gt;'plTenjin Example', items=&gt;['&lt;AAA&gt;','B&amp;B','"CCC"'], };
#$context = <strong>new Tenjin::Context($context)</strong>;
#my $output = <strong>$template-&gt;render($context)</strong>;
## or
#my $context = new Tenjin::Context();
#$context-&gt;{'title'} = 'plTenjin Example';
#$context-&gt;{'items'} = ['&lt;AAA&gt;','B&amp;B','"CCC"'];
#my $output = $template-&gt;render(context);
</pre>
<a name="example14_tmplclass.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ perl example14.pl
---- perl code ----
my @_buf = (); push(@_buf, q`&lt;h1&gt;`, escape($title), q`&lt;/h1&gt;
&lt;ul&gt;
`, ); for my $item (@$items) {
push(@_buf, q` &lt;li&gt;`, escape($item), q`&lt;/li&gt;
`, ); }
push(@_buf, q`&lt;/ul&gt;
`, ); join('', @_buf);
---- output ----
&lt;h1&gt;plTenjin Example&lt;/h1&gt;
&lt;ul&gt;
 &lt;li&gt;&amp;lt;AAA&amp;gt;&lt;/li&gt;
 &lt;li&gt;B&amp;amp;B&lt;/li&gt;
 &lt;li&gt;&amp;quot;CCC&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>Constructor of Tenjin::Template can take the follwoing options.
</p>
<ul type="disc">
<li>'<code>escapefunc</code>' (string) specifies function name to escape string.
  Default is '<code>escape</code>' (= <code>Tenjin::Context::escape</code>).
</li>
</ul>
<p>Constructor of Tenjin::Engine can also take the same options as above.
These options given to constructor of Tenjin::Engine are passed to constructor of Tenjin::Template internally.
</p>
<a name="example15.pl"></a>
<div class="program_caption">
File 'example15.pl':</div>
<pre class="program">use Tenjin;
use strict;
my $filename = 'example14.plhtml';
my $template = new Tenjin::Template($filename, <strong>{escapefunc=&gt;'HTML::Entities::encode_entities'}</strong>);
print $template-&gt;{script}, "\n";

use HTML::Entities;
my $title = 'plTenjin Example';
my $items = ['&lt;foo&gt;', '&amp;bar', '"baz"'];
my $output = $template-&gt;render({title=&gt;$title, items=&gt;$items});
print $output;
</pre>
<a name="example15_escapefunc.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ perl example15.pl
my @_buf = (); push(@_buf, q`&lt;h1&gt;`, HTML::Entities::encode_entities($title), q`&lt;/h1&gt;
&lt;ul&gt;
`, ); for my $item (@$items) {
push(@_buf, q` &lt;li&gt;`, HTML::Entities::encode_entities($item), q`&lt;/li&gt;
`, ); }
push(@_buf, q`&lt;/ul&gt;
`, ); join('', @_buf);

&lt;h1&gt;plTenjin Example&lt;/h1&gt;
&lt;ul&gt;
 &lt;li&gt;&amp;lt;foo&amp;gt;&lt;/li&gt;
 &lt;li&gt;&amp;amp;bar&lt;/li&gt;
 &lt;li&gt;&amp;quot;baz&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
</pre>
<br>


<a name="dev-engineclass"></a>
<h3 class="section2">Class Tenjin::Engine</h3>
<p>Tenjin::Engine class contains some template objects.
It can handle nested template and layout template.
This class provides many features such as:
</p>
<ul type="circle">
<li>Search template files
</li>
<li>Nestable layout template
</li>
<li>Partial template
</li>
<li><s>File caching</s> (caching feature is separated to tenjin.CacheStorage class.)
</li>
<li>Preprocessing
</li>
<li>and so on
</li>
</ul>
<p>This class has the following methods.
</p>
<dl class="dl3">
<dt class="dt3"><b>
Tenjin::Engine::new({prefix=&gt;'', postfix=&gt;'', layout=&gt;undef, path=undef, cache=&gt;1, preprocess=&gt;0, templateclass=&gt;'Tenjin::Template'}) </b></dt>
<dd class="dd3">
    Create Engine object.
    <code>path</code> represents template search path and it should be an Array of directory name.
    Other arguments are passed to Tenjin::Template::new() internally.
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
Tenjin::Engine#render(template_name, context=undef, layout=1) </b></dt>
<dd class="dd3">
    Convert template into Perl code, evaluate it with context data, and return the result of it.
    If <code>layout</code> is 1 then layout template name specified by constructor option is
    used as layout template, else if 0 then layout template is not used,
    else if string then it is regarded as layout template name.
</dd>
</dl>
<p>Argument <code>template_name</code> in render() methods is filename or short name of template.
Template short name is a string starting with colon (':').
For example, '<code>render(":list", $context)</code>' is equivarent to '<code>render("user_list.plhtml", $context)</code>' if prefix option is '<code>user_</code>' and postfix option is '<code>.plhtml</code>'.
</p>
<br>


<a name="dev-vars-and-funcs"></a>
<h3 class="section2">Variables and Functions</h3>
<p>In template file, the following variables and functions are available.
</p>
<dl class="dl3">
<dt class="dt3"><b>
$_content </b></dt>
<dd class="dd3">
    This variable represents the result of evaluation of other template.
    This is available only in layout template file.
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
$_context </b></dt>
<dd class="dd3">
    This variable represents context data dictionary and same as the 2nd argument of tenjin.Engine.render().
    You can tweak this dict. For example if you set <code>_context['title']="Example"</code> in your template file, <code>title</code> variable will be available in layout template file.
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
include($template_name) </b></dt>
<dd class="dd3">
    Include other template file.
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
start_capture(name) </b></dt>
<dd class="dd3">
    Start capturing. Result will be stored into <code>$_context-&gt;{<em>name</em>}</code>.
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
stop_capture() </b></dt>
<dd class="dd3">
    Stop capturing.
</dd>
</dl>
<dl class="dl3">
<dt class="dt3"><b>
start_placeholder(varname), stop_placeholder() </b></dt>
<dd class="dd3">
    Placeholder is a region from start_placeholder() to stop_placeholder().
    If captured string as <em>varname</em> exists then use it as content,
    else use content in placeholder as is.
    For example,
<pre class="terminal">&lt;?pl start_placeholder('foo'); ?&gt;
  ...
&lt;?pl stop_placeholder(); ?&gt;
</pre>
    is equivarent to:
<pre class="terminal">&lt;?pl if (defined($_context-&gt;{'foo'})) { ?&gt;
&lt;?pl     push(@_buf, $_contet-&gt;{'foo'}); ?&gt;
&lt;?pl } else { ?&gt;
  ...
&lt;?pl } ?&gt;
</pre>
</dd>
</dl>
<p>(Notice that include(), start_capture(), stop_capture(), start_placeholder(), and stop_placeholder() are built-in macros of plTenjin and they are not subroutine of Perl.)
</p>
<p>The followings are example of Tenjin::Engine class.
</p>
<a name="user_form.plhtml"></a>
<div class="program_caption">
File 'user_form.plhtml':</div>
<pre class="program">&lt;?pl #@ARGS params ?&gt;
&lt;p&gt;
  Name:  &lt;input type="text" name="name"  value="[=$params-&gt;{name}=]" /&gt;&lt;br /&gt;
  Email: &lt;input type="text" name="email" value="[=$params-&gt;{email}=]" /&gt;&lt;br /&gt;
  Gender:
&lt;?pl my $gender = $params-&gt;{gender}; ?&gt;
&lt;?pl my %chk = (1==1 =&gt; ' checked="checked"', 1==0 =&gt; ''); ?&gt;
  &lt;input type="radio" name="gender" value="m" [==$chk{$gender eq 'm'}=] /&gt;Male
  &lt;input type="radio" name="gender" value="f" [==$chk{$gender eq 'f'}=] /&gt;Female
&lt;/p&gt;
</pre>
<a name="user_create.plhtml"></a>
<div class="program_caption">
File 'user_create.plhtml':</div>
<pre class="program">&lt;?pl #@ARGS ?&gt;
&lt;form action="user_app.cgi" method="post"&gt;
  &lt;input type="hidden" name="action" value="create" /&gt;
<strong>&lt;?pl include(':form'); ?&gt;</strong>
  &lt;input type="submit" value="Create" /&gt;
&lt;/form&gt;
</pre>
<a name="user_edit.plhtml"></a>
<div class="program_caption">
File 'user_edit.plhtml':</div>
<pre class="program">&lt;?pl #@ARGS params ?&gt;
&lt;form action="user_app.cgi" method="post"&gt;
  &lt;input type="hidden" name="action" value="edit" /&gt;
  &lt;input type="hidden" name="id" value="[= $params-&gt;{id} =]" /&gt;
<strong>&lt;?pl include(':form'); ?&gt;</strong>
  &lt;input type="submit" value="Edit" /&gt;
&lt;/form&gt;
</pre>
<a name="user_layout.plhtml"></a>
<div class="program_caption">
File 'user_layout.plhtml':</div>
<pre class="program">&lt;?pl #@ARGS _content, title ?&gt;
&lt;html&gt;
  &lt;body&gt;

    &lt;h1&gt;[=$title=]&lt;/h1&gt;

    &lt;div id="main-content"&gt;
<strong>[==$_content==]</strong>
    &lt;/div&gt;

    &lt;div id="footer"&gt;
<strong>&lt;?pl include('footer.html'); ?&gt;</strong>
    &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>
<a name="footer.html"></a>
<div class="program_caption">
File 'footer.html':</div>
<pre class="program">&lt;?pl #@ARGS ?&gt;
&lt;hr /&gt;
&lt;address&gt;
  &lt;a href="mailto:webmaster@example.com"&gt;webmaster@example.com&lt;/a&gt;
&lt;/address&gt;
</pre>
<a name="user_app.cgi"></a>
<div class="program_caption">
File 'user_app.cgi':</div>
<pre class="program">#!/usr/bin/env perl

use CGI;
use strict;
<strong>use Tenjin</strong>;

## set action ('create' or 'edit')
my ($action, $cgi);
if ($ENV{'REQUEST_METHOD'}) {
    $cgi = new CGI();
    $action = $cgi-&gt;param('action');
}
elsif ($ARGV[0]) {
    $action = $ARGV[0];
}
$action = 'create' unless $action eq 'create' || $action eq 'edit';

## set context data
my ($title, $params);
if ($action eq 'create') {
    $title = 'Create User';
    $params = { };
}
else {
    $title = 'Edit User';
    $params = {
        name=&gt;'Margalette',
        email=&gt;'meg@example.com',
        gender=&gt;'f',
	id=&gt;123,
    };
}
<strong>my $context = { title=&gt;$title, params=&gt;$params, }</strong>;
<strong># or $context = new Tenjin::Context({title=&gt;$title, $params=&gt;params})</strong>

## create engine object
my $layout = ':layout';   # or 'user_layout.plhtml'
my $engine = <strong>new Tenjin::Engine({prefix=&gt;'user_', postfix=&gt;'.plhtml', layout=&gt;$layout})</strong>;

## evaluate template
my $template_name = ":$action";  # :create or :edit
my $output = <strong>$engine-&gt;render($template_name, $context)</strong>;
print $cgi-&gt;header() if $cgi;
print $output;
</pre>
<a name="user_app.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ perl user_app.cgi create
&lt;html&gt;
  &lt;body&gt;

    &lt;h1&gt;Create User&lt;/h1&gt;

    &lt;div id="main-content"&gt;
<strong>&lt;form action="user_app.cgi" method="post"&gt;</strong>
<strong>  &lt;input type="hidden" name="action" value="create" /&gt;</strong>
<strong>&lt;p&gt;</strong>
<strong>  Name:  &lt;input type="text" name="name"  value="" /&gt;&lt;br /&gt;</strong>
<strong>  Email: &lt;input type="text" name="email" value="" /&gt;&lt;br /&gt;</strong>
<strong>  Gender:</strong>
<strong>  &lt;input type="radio" name="gender" value="m"  /&gt;Male</strong>
<strong>  &lt;input type="radio" name="gender" value="f"  /&gt;Female</strong>
<strong>&lt;/p&gt;</strong>
<strong>  &lt;input type="submit" value="Create" /&gt;</strong>
<strong>&lt;/form&gt;</strong>
    &lt;/div&gt;

    &lt;div id="footer"&gt;
<strong>&lt;hr /&gt;</strong>
<strong>&lt;address&gt;</strong>
<strong>  &lt;a href="mailto:webmaster@example.com"&gt;webmaster@example.com&lt;/a&gt;</strong>
<strong>&lt;/address&gt;</strong>
    &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>
<br>


<a name="dev-helpers"></a>
<h3 class="section2">Add Your Helper Functions</h3>
<p>There are several ways to use helper functions.
</p>
<p>(A) Add package prefix for each helper functions.
</p>
<a name="example16a.plhtml"></a>
<div class="program_caption">
File 'example16a.plhtml':</div>
<pre class="program">&lt;?pl #@ARGS label, url ?&gt;
&lt;ul&gt;
  &lt;li&gt;[==<strong>::link_to($label, $url)</strong>=]&lt;/li&gt;
&lt;/ul&gt;
</pre>
<a name="example16a.pl"></a>
<div class="program_caption">
File 'example16a.pl':</div>
<pre class="program">use Tenjin;

sub link_to {
    my ($label, $url) = @_;
    $label = Tenjin::Helper::Html::escape_xml($label);
    $url = Tenjin::Helper::Html::escape_xml($url);
    return "&lt;a href=\"$url\"&gt;$label&lt;/a&gt;";
}

my $engine = new Tenjin::Engine();
my $context = { 'label'=&gt;'Top', 'url'=&gt;'/' };
my $output = $engine-&gt;render('example16a.plhtml', $context);
print $output;
</pre>
<a name="example16a.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ perl example16a.pl
&lt;ul&gt;
  &lt;li&gt;&lt;a href="/"&gt;Top&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>(B) Define submodule of Tenjin::Context and define helper functions in it.
</p>
<a name="example16b.plhtml"></a>
<div class="program_caption">
File 'example16b.plhtml':</div>
<pre class="program">&lt;?pl #@ARGS label, url ?&gt;
&lt;ul&gt;
  &lt;li&gt;[==<strong>link_to($label, $url)</strong>=]&lt;/li&gt;
&lt;/ul&gt;
</pre>
<a name="example16b.pl"></a>
<div class="program_caption">
File 'example16b.pl':</div>
<pre class="program">use Tenjin;

<strong>package MyContext;</strong>
@ISA = ('Tenjin::Context');
eval $Tenjin::Context::defun;  # define 'evaluate()' and 'to_func()'
*escape = *Tenjin::Helper::Html::escape_xml;

sub link_to {
    my ($label, $url) = @_;
    $label = escape($label);
    $url = escape($url);
    return "&lt;a href=\"$url\"&gt;$label&lt;/a&gt;";
}

package main;
<strong>$Tenjin::CONTEXT_CLASS = 'MyContext';</strong>  # use MyContext instead of Tenjin::Context

my $engine = new Tenjin::Engine();
my $context = { 'label'=&gt;'Top', 'url'=&gt;'/' };
my $output = $engine-&gt;render('example16b.plhtml', $context);
print $output;
</pre>
<a name="example16b.result"></a>
<div class="terminal_caption">
Result:</div>
<pre class="terminal">$ perl example16b.pl
&lt;ul&gt;
  &lt;li&gt;&lt;a href="/"&gt;Top&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</pre>
<br>


<a name="dev-othertopics"></a>
<h3 class="section2">Other Topics</h3>
<ul type="disc">
<li>If you set '$Tenjin::USE_STRICT' to 1, Tenjin::Template::render() uses strict package.
   This is useful for development.
</li>
</ul>
<ul type="disc">
<li>Tenjin::Template detects newline character ("\n" or "\r\n") automatically.
   If input file contains "\r\n", plTenjin generates output which contains "\r\n".
</li>
</ul>
<ul type="disc">
<li>Tenjin::Template::render() can be called many times.
   If you create a Tenjin::Template object, you can call render() method many times.
</li>
</ul>
<ul type="disc">
<li>Tenjin::Template::convert() also can be called many times.
  If you create a Tenjin::Template object, you can call convert() (and also render()) method many times.
</li>
</ul>
<br>


<br>



   </div>
  </blockquote>

 </body>
</html>
